{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"claire Command Line AI Request Experience Usage Commands Usage $ npm install -g @claire-ac/cli $ claire COMMAND running command... $ claire (--version) @claire-ac/cli/0.2.0 darwin-arm64 node-v22.14.0 $ claire --help [COMMAND] USAGE $ claire COMMAND ... Commands claire api:invitation:create [EMAIL] claire api:invitation:list claire api:project:create claire api:project:set claire api:project:show [PROJECTID] claire api:project:update claire api:question:show [QUESTIONID] claire ask claire config claire help [COMMAND] claire info claire init claire plugins claire plugins:add PLUGIN claire plugins:inspect PLUGIN... claire plugins:install PLUGIN claire plugins:link PATH claire plugins:remove [PLUGIN] claire plugins:reset claire plugins:uninstall [PLUGIN] claire plugins:unlink [PLUGIN] claire plugins:update claire api:invitation:create [EMAIL] Send CLaiRE invitation to a new user. USAGE $ claire api:invitation:create [EMAIL] ARGUMENTS EMAIL Email of the user to invite to CLaiRE DESCRIPTION Send CLaiRE invitation to a new user. See code: src/commands/api/invitation/create.ts claire api:invitation:list Show sent CLaiRE invitations. USAGE $ claire api:invitation:list DESCRIPTION Show sent CLaiRE invitations. See code: src/commands/api/invitation/list.ts claire api:project:create Create new project in CLaiRE API USAGE $ claire api:project:create [--name <value>] [--description <value>] FLAGS --description=<value> Project description --name=<value> Project name DESCRIPTION Create new project in CLaiRE API See code: src/commands/api/project/create.ts claire api:project:set List users projects and set active project in CLaiRE config. USAGE $ claire api:project:set DESCRIPTION List users projects and set active project in CLaiRE config. See code: src/commands/api/project/set.ts claire api:project:show [PROJECTID] Show information for CLaiRE project USAGE $ claire api:project:show [PROJECTID] [--list] [-p <value>] ARGUMENTS PROJECTID ID of project to display FLAGS -p, --projectId=<value> ID of project to display --list List projects and select to view DESCRIPTION Show information for CLaiRE project See code: src/commands/api/project/show.ts claire api:project:update Update project information in CLaiRE API USAGE $ claire api:project:update DESCRIPTION Update project information in CLaiRE API See code: src/commands/api/project/update.ts claire api:question:show [QUESTIONID] Show details for CLaiRE question USAGE $ claire api:question:show [QUESTIONID] [--list] [-q <value>] [-s] ARGUMENTS QUESTIONID ID of question to display FLAGS -q, --questionId=<value> ID of question to display -s, --skipResponse Do not include question response in output --list List questions and select to view DESCRIPTION Show details for CLaiRE question See code: src/commands/api/question/show.ts claire ask Send a prompt to CLaiRE API and retrieve a response. USAGE $ claire ask [-p <value>] [-F <value>...] [-c <value>...] FLAGS -F, --inputFile=<value>... Path to file(s) containing the question input -c, --contextIds=<value>... Comma-separated list of context IDs -p, --prompt=<value> Prompt to send DESCRIPTION Send a prompt to CLaiRE API and retrieve a response. EXAMPLES $ claire ask -p \"How do I add ActiveAdmin to a Rails 7 app?\" $ claire ask -p \"Refactor this file\" -F path/to/src/file.ts $ claire ask -F path/to/input.txt $ claire ask -p \"Help me combine these files:\" -F path/to/file1.ts -F path/to/file2.ts $ claire ask -p \"Analyze this code\" -c 123 -c 456 See code: src/commands/ask.ts claire config View current or set new CLaiRE configuration values. USAGE $ claire config [-h <value>] [-t <value>] FLAGS -h, --host=<value> Set API base URL -t, --token=<value> Set CLaiRE API key DESCRIPTION View current or set new CLaiRE configuration values. See code: src/commands/config.ts claire help [COMMAND] Display help for claire. USAGE $ claire help [COMMAND...] [-n] ARGUMENTS COMMAND... Command to show help for. FLAGS -n, --nested-commands Include all nested commands in the output. DESCRIPTION Display help for claire. See code: @oclif/plugin-help claire info Display current project and configuration information. USAGE $ claire info DESCRIPTION Display current project and configuration information. See code: src/commands/info.ts claire init Initialize CLaiRE CLI. USAGE $ claire init DESCRIPTION Initialize CLaiRE CLI. See code: src/commands/init.ts claire plugins List installed plugins. USAGE $ claire plugins [--json] [--core] FLAGS --core Show core plugins. GLOBAL FLAGS --json Format output as json. DESCRIPTION List installed plugins. EXAMPLES $ claire plugins See code: @oclif/plugin-plugins claire plugins:add PLUGIN Installs a plugin into claire. USAGE $ claire plugins:add PLUGIN... [--json] [-f] [-h] [-s | -v] ARGUMENTS PLUGIN... Plugin to install. FLAGS -f, --force Force npm to fetch remote resources even if a local copy exists on disk. -h, --help Show CLI help. -s, --silent Silences npm output. -v, --verbose Show verbose npm output. GLOBAL FLAGS --json Format output as json. DESCRIPTION Installs a plugin into claire. Uses npm to install plugins. Installation of a user-installed plugin will override a core plugin. Use the CLAIRE_NPM_LOG_LEVEL environment variable to set the npm loglevel. Use the CLAIRE_NPM_REGISTRY environment variable to set the npm registry. ALIASES $ claire plugins:add EXAMPLES Install a plugin from npm registry. $ claire plugins:add myplugin Install a plugin from a github url. $ claire plugins:add https://github.com/someuser/someplugin Install a plugin from a github slug. $ claire plugins:add someuser/someplugin claire plugins:inspect PLUGIN... Displays installation properties of a plugin. USAGE $ claire plugins:inspect PLUGIN... ARGUMENTS PLUGIN... [default: .] Plugin to inspect. FLAGS -h, --help Show CLI help. -v, --verbose GLOBAL FLAGS --json Format output as json. DESCRIPTION Displays installation properties of a plugin. EXAMPLES $ claire plugins:inspect myplugin See code: @oclif/plugin-plugins claire plugins:install PLUGIN Installs a plugin into claire. USAGE $ claire plugins:install PLUGIN... [--json] [-f] [-h] [-s | -v] ARGUMENTS PLUGIN... Plugin to install. FLAGS -f, --force Force npm to fetch remote resources even if a local copy exists on disk. -h, --help Show CLI help. -s, --silent Silences npm output. -v, --verbose Show verbose npm output. GLOBAL FLAGS --json Format output as json. DESCRIPTION Installs a plugin into claire. Uses npm to install plugins. Installation of a user-installed plugin will override a core plugin. Use the CLAIRE_NPM_LOG_LEVEL environment variable to set the npm loglevel. Use the CLAIRE_NPM_REGISTRY environment variable to set the npm registry. ALIASES $ claire plugins:add EXAMPLES Install a plugin from npm registry. $ claire plugins:install myplugin Install a plugin from a github url. $ claire plugins:install https://github.com/someuser/someplugin Install a plugin from a github slug. $ claire plugins:install someuser/someplugin See code: @oclif/plugin-plugins claire plugins:link PATH Links a plugin into the CLI for development. USAGE $ claire plugins:link PATH [-h] [--install] [-v] ARGUMENTS PATH [default: .] path to plugin FLAGS -h, --help Show CLI help. -v, --verbose --[no-]install Install dependencies after linking the plugin. DESCRIPTION Links a plugin into the CLI for development. Installation of a linked plugin will override a user-installed or core plugin. e.g. If you have a user-installed or core plugin that has a 'hello' command, installing a linked plugin with a 'hello' command will override the user-installed or core plugin implementation. This is useful for development work. EXAMPLES $ claire plugins:link myplugin See code: @oclif/plugin-plugins claire plugins:remove [PLUGIN] Removes a plugin from the CLI. USAGE $ claire plugins:remove [PLUGIN...] [-h] [-v] ARGUMENTS PLUGIN... plugin to uninstall FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Removes a plugin from the CLI. ALIASES $ claire plugins:unlink $ claire plugins:remove EXAMPLES $ claire plugins:remove myplugin claire plugins:reset Remove all user-installed and linked plugins. USAGE $ claire plugins:reset [--hard] [--reinstall] FLAGS --hard Delete node_modules and package manager related files in addition to uninstalling plugins. --reinstall Reinstall all plugins after uninstalling. See code: @oclif/plugin-plugins claire plugins:uninstall [PLUGIN] Removes a plugin from the CLI. USAGE $ claire plugins:uninstall [PLUGIN...] [-h] [-v] ARGUMENTS PLUGIN... plugin to uninstall FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Removes a plugin from the CLI. ALIASES $ claire plugins:unlink $ claire plugins:remove EXAMPLES $ claire plugins:uninstall myplugin See code: @oclif/plugin-plugins claire plugins:unlink [PLUGIN] Removes a plugin from the CLI. USAGE $ claire plugins:unlink [PLUGIN...] [-h] [-v] ARGUMENTS PLUGIN... plugin to uninstall FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Removes a plugin from the CLI. ALIASES $ claire plugins:unlink $ claire plugins:remove EXAMPLES $ claire plugins:unlink myplugin claire plugins:update Update installed plugins. USAGE $ claire plugins:update [-h] [-v] FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Update installed plugins. See code: @oclif/plugin-plugins","title":"Documention Home"},{"location":"#claire","text":"Command Line AI Request Experience Usage Commands","title":"claire"},{"location":"#usage","text":"$ npm install -g @claire-ac/cli $ claire COMMAND running command... $ claire (--version) @claire-ac/cli/0.2.0 darwin-arm64 node-v22.14.0 $ claire --help [COMMAND] USAGE $ claire COMMAND ...","title":"Usage"},{"location":"#commands","text":"claire api:invitation:create [EMAIL] claire api:invitation:list claire api:project:create claire api:project:set claire api:project:show [PROJECTID] claire api:project:update claire api:question:show [QUESTIONID] claire ask claire config claire help [COMMAND] claire info claire init claire plugins claire plugins:add PLUGIN claire plugins:inspect PLUGIN... claire plugins:install PLUGIN claire plugins:link PATH claire plugins:remove [PLUGIN] claire plugins:reset claire plugins:uninstall [PLUGIN] claire plugins:unlink [PLUGIN] claire plugins:update","title":"Commands"},{"location":"#claire-apiinvitationcreate-email","text":"Send CLaiRE invitation to a new user. USAGE $ claire api:invitation:create [EMAIL] ARGUMENTS EMAIL Email of the user to invite to CLaiRE DESCRIPTION Send CLaiRE invitation to a new user. See code: src/commands/api/invitation/create.ts","title":"claire api:invitation:create [EMAIL]"},{"location":"#claire-apiinvitationlist","text":"Show sent CLaiRE invitations. USAGE $ claire api:invitation:list DESCRIPTION Show sent CLaiRE invitations. See code: src/commands/api/invitation/list.ts","title":"claire api:invitation:list"},{"location":"#claire-apiprojectcreate","text":"Create new project in CLaiRE API USAGE $ claire api:project:create [--name <value>] [--description <value>] FLAGS --description=<value> Project description --name=<value> Project name DESCRIPTION Create new project in CLaiRE API See code: src/commands/api/project/create.ts","title":"claire api:project:create"},{"location":"#claire-apiprojectset","text":"List users projects and set active project in CLaiRE config. USAGE $ claire api:project:set DESCRIPTION List users projects and set active project in CLaiRE config. See code: src/commands/api/project/set.ts","title":"claire api:project:set"},{"location":"#claire-apiprojectshow-projectid","text":"Show information for CLaiRE project USAGE $ claire api:project:show [PROJECTID] [--list] [-p <value>] ARGUMENTS PROJECTID ID of project to display FLAGS -p, --projectId=<value> ID of project to display --list List projects and select to view DESCRIPTION Show information for CLaiRE project See code: src/commands/api/project/show.ts","title":"claire api:project:show [PROJECTID]"},{"location":"#claire-apiprojectupdate","text":"Update project information in CLaiRE API USAGE $ claire api:project:update DESCRIPTION Update project information in CLaiRE API See code: src/commands/api/project/update.ts","title":"claire api:project:update"},{"location":"#claire-apiquestionshow-questionid","text":"Show details for CLaiRE question USAGE $ claire api:question:show [QUESTIONID] [--list] [-q <value>] [-s] ARGUMENTS QUESTIONID ID of question to display FLAGS -q, --questionId=<value> ID of question to display -s, --skipResponse Do not include question response in output --list List questions and select to view DESCRIPTION Show details for CLaiRE question See code: src/commands/api/question/show.ts","title":"claire api:question:show [QUESTIONID]"},{"location":"#claire-ask","text":"Send a prompt to CLaiRE API and retrieve a response. USAGE $ claire ask [-p <value>] [-F <value>...] [-c <value>...] FLAGS -F, --inputFile=<value>... Path to file(s) containing the question input -c, --contextIds=<value>... Comma-separated list of context IDs -p, --prompt=<value> Prompt to send DESCRIPTION Send a prompt to CLaiRE API and retrieve a response. EXAMPLES $ claire ask -p \"How do I add ActiveAdmin to a Rails 7 app?\" $ claire ask -p \"Refactor this file\" -F path/to/src/file.ts $ claire ask -F path/to/input.txt $ claire ask -p \"Help me combine these files:\" -F path/to/file1.ts -F path/to/file2.ts $ claire ask -p \"Analyze this code\" -c 123 -c 456 See code: src/commands/ask.ts","title":"claire ask"},{"location":"#claire-config","text":"View current or set new CLaiRE configuration values. USAGE $ claire config [-h <value>] [-t <value>] FLAGS -h, --host=<value> Set API base URL -t, --token=<value> Set CLaiRE API key DESCRIPTION View current or set new CLaiRE configuration values. See code: src/commands/config.ts","title":"claire config"},{"location":"#claire-help-command","text":"Display help for claire. USAGE $ claire help [COMMAND...] [-n] ARGUMENTS COMMAND... Command to show help for. FLAGS -n, --nested-commands Include all nested commands in the output. DESCRIPTION Display help for claire. See code: @oclif/plugin-help","title":"claire help [COMMAND]"},{"location":"#claire-info","text":"Display current project and configuration information. USAGE $ claire info DESCRIPTION Display current project and configuration information. See code: src/commands/info.ts","title":"claire info"},{"location":"#claire-init","text":"Initialize CLaiRE CLI. USAGE $ claire init DESCRIPTION Initialize CLaiRE CLI. See code: src/commands/init.ts","title":"claire init"},{"location":"#claire-plugins","text":"List installed plugins. USAGE $ claire plugins [--json] [--core] FLAGS --core Show core plugins. GLOBAL FLAGS --json Format output as json. DESCRIPTION List installed plugins. EXAMPLES $ claire plugins See code: @oclif/plugin-plugins","title":"claire plugins"},{"location":"#claire-pluginsadd-plugin","text":"Installs a plugin into claire. USAGE $ claire plugins:add PLUGIN... [--json] [-f] [-h] [-s | -v] ARGUMENTS PLUGIN... Plugin to install. FLAGS -f, --force Force npm to fetch remote resources even if a local copy exists on disk. -h, --help Show CLI help. -s, --silent Silences npm output. -v, --verbose Show verbose npm output. GLOBAL FLAGS --json Format output as json. DESCRIPTION Installs a plugin into claire. Uses npm to install plugins. Installation of a user-installed plugin will override a core plugin. Use the CLAIRE_NPM_LOG_LEVEL environment variable to set the npm loglevel. Use the CLAIRE_NPM_REGISTRY environment variable to set the npm registry. ALIASES $ claire plugins:add EXAMPLES Install a plugin from npm registry. $ claire plugins:add myplugin Install a plugin from a github url. $ claire plugins:add https://github.com/someuser/someplugin Install a plugin from a github slug. $ claire plugins:add someuser/someplugin","title":"claire plugins:add PLUGIN"},{"location":"#claire-pluginsinspect-plugin","text":"Displays installation properties of a plugin. USAGE $ claire plugins:inspect PLUGIN... ARGUMENTS PLUGIN... [default: .] Plugin to inspect. FLAGS -h, --help Show CLI help. -v, --verbose GLOBAL FLAGS --json Format output as json. DESCRIPTION Displays installation properties of a plugin. EXAMPLES $ claire plugins:inspect myplugin See code: @oclif/plugin-plugins","title":"claire plugins:inspect PLUGIN..."},{"location":"#claire-pluginsinstall-plugin","text":"Installs a plugin into claire. USAGE $ claire plugins:install PLUGIN... [--json] [-f] [-h] [-s | -v] ARGUMENTS PLUGIN... Plugin to install. FLAGS -f, --force Force npm to fetch remote resources even if a local copy exists on disk. -h, --help Show CLI help. -s, --silent Silences npm output. -v, --verbose Show verbose npm output. GLOBAL FLAGS --json Format output as json. DESCRIPTION Installs a plugin into claire. Uses npm to install plugins. Installation of a user-installed plugin will override a core plugin. Use the CLAIRE_NPM_LOG_LEVEL environment variable to set the npm loglevel. Use the CLAIRE_NPM_REGISTRY environment variable to set the npm registry. ALIASES $ claire plugins:add EXAMPLES Install a plugin from npm registry. $ claire plugins:install myplugin Install a plugin from a github url. $ claire plugins:install https://github.com/someuser/someplugin Install a plugin from a github slug. $ claire plugins:install someuser/someplugin See code: @oclif/plugin-plugins","title":"claire plugins:install PLUGIN"},{"location":"#claire-pluginslink-path","text":"Links a plugin into the CLI for development. USAGE $ claire plugins:link PATH [-h] [--install] [-v] ARGUMENTS PATH [default: .] path to plugin FLAGS -h, --help Show CLI help. -v, --verbose --[no-]install Install dependencies after linking the plugin. DESCRIPTION Links a plugin into the CLI for development. Installation of a linked plugin will override a user-installed or core plugin. e.g. If you have a user-installed or core plugin that has a 'hello' command, installing a linked plugin with a 'hello' command will override the user-installed or core plugin implementation. This is useful for development work. EXAMPLES $ claire plugins:link myplugin See code: @oclif/plugin-plugins","title":"claire plugins:link PATH"},{"location":"#claire-pluginsremove-plugin","text":"Removes a plugin from the CLI. USAGE $ claire plugins:remove [PLUGIN...] [-h] [-v] ARGUMENTS PLUGIN... plugin to uninstall FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Removes a plugin from the CLI. ALIASES $ claire plugins:unlink $ claire plugins:remove EXAMPLES $ claire plugins:remove myplugin","title":"claire plugins:remove [PLUGIN]"},{"location":"#claire-pluginsreset","text":"Remove all user-installed and linked plugins. USAGE $ claire plugins:reset [--hard] [--reinstall] FLAGS --hard Delete node_modules and package manager related files in addition to uninstalling plugins. --reinstall Reinstall all plugins after uninstalling. See code: @oclif/plugin-plugins","title":"claire plugins:reset"},{"location":"#claire-pluginsuninstall-plugin","text":"Removes a plugin from the CLI. USAGE $ claire plugins:uninstall [PLUGIN...] [-h] [-v] ARGUMENTS PLUGIN... plugin to uninstall FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Removes a plugin from the CLI. ALIASES $ claire plugins:unlink $ claire plugins:remove EXAMPLES $ claire plugins:uninstall myplugin See code: @oclif/plugin-plugins","title":"claire plugins:uninstall [PLUGIN]"},{"location":"#claire-pluginsunlink-plugin","text":"Removes a plugin from the CLI. USAGE $ claire plugins:unlink [PLUGIN...] [-h] [-v] ARGUMENTS PLUGIN... plugin to uninstall FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Removes a plugin from the CLI. ALIASES $ claire plugins:unlink $ claire plugins:remove EXAMPLES $ claire plugins:unlink myplugin","title":"claire plugins:unlink [PLUGIN]"},{"location":"#claire-pluginsupdate","text":"Update installed plugins. USAGE $ claire plugins:update [-h] [-v] FLAGS -h, --help Show CLI help. -v, --verbose DESCRIPTION Update installed plugins. See code: @oclif/plugin-plugins","title":"claire plugins:update"},{"location":"CLI/","text":"CLaiRE CLI Installation and Configuration Installing NPMjs npm install -g @claire-ac/cli Initialize the CLI claire init Configuring claire config claire config -t {API_TOKEN} find your CLaiRE API token in your admin dashboard https://claire.ac/admin Creating Projects claire api:project:create - name - description - ai_model - system_message (optional) Setting Current Project claire api:project:set no flags necessary; choose project from list to set as current project for API Sending AI Prompts claire ask claire ask -p \"prompt goes here\" claire ask -F path/to/input/file if no flags supplied claire prompts you on the command line claire ask allows you to supply both a prompt using the -p tag as well as an input file using -F claire ask allows you to supply multiple input files using the following format: claire ask -F path/to/input1 -F path/to/input2 claire ask -p \"Analye the following files, refactor if necessary, and merge into a single source file\" -F path/to/source1 -F path/to/source 2 View API Data claire api:project:show --list claire api:project:show {PROJECT_ID} claire api:question:show --list claire api:question:show {QUESTION_ID} Invite Users to CLaiRE claire api:invitation:create {USER_EMAIL} if no {USER_EMAIL} supplied claire will prompt for one on the command line","title":"Installing CLI"},{"location":"CLI/#claire-cli-installation-and-configuration","text":"","title":"CLaiRE CLI Installation and Configuration"},{"location":"CLI/#installing","text":"","title":"Installing"},{"location":"CLI/#npmjs","text":"npm install -g @claire-ac/cli","title":"NPMjs"},{"location":"CLI/#initialize-the-cli","text":"claire init","title":"Initialize the CLI"},{"location":"CLI/#configuring","text":"claire config claire config -t {API_TOKEN} find your CLaiRE API token in your admin dashboard https://claire.ac/admin","title":"Configuring"},{"location":"CLI/#creating-projects","text":"claire api:project:create - name - description - ai_model - system_message (optional)","title":"Creating Projects"},{"location":"CLI/#setting-current-project","text":"claire api:project:set no flags necessary; choose project from list to set as current project for API","title":"Setting Current Project"},{"location":"CLI/#sending-ai-prompts","text":"claire ask claire ask -p \"prompt goes here\" claire ask -F path/to/input/file if no flags supplied claire prompts you on the command line claire ask allows you to supply both a prompt using the -p tag as well as an input file using -F claire ask allows you to supply multiple input files using the following format: claire ask -F path/to/input1 -F path/to/input2 claire ask -p \"Analye the following files, refactor if necessary, and merge into a single source file\" -F path/to/source1 -F path/to/source 2","title":"Sending AI Prompts"},{"location":"CLI/#view-api-data","text":"claire api:project:show --list claire api:project:show {PROJECT_ID} claire api:question:show --list claire api:question:show {QUESTION_ID}","title":"View API Data"},{"location":"CLI/#invite-users-to-claire","text":"claire api:invitation:create {USER_EMAIL} if no {USER_EMAIL} supplied claire will prompt for one on the command line","title":"Invite Users to CLaiRE"},{"location":"ai-models/OVERVIEW/","text":"AI Models Overview Models o3-mini o1-mini gpt-4o-mini gpt-4o chatgpt-4o-latest Overview Below is an overview of the AI models and how they compare for code completion tasks in a programming context. In this lineup, each model represents an evolution in capability and context sensitivity when generating and refining code. (The numerical level identifiers can be thought of as \"contextual levels\" with higher numbers offering more advanced completions.) - o3-mini (Level 0) Description: \u2013 This is a very lightweight model optimized for speed. \u2013 It has a limited capacity in terms of both context window and complexity of reasoning. \u2013 It works best for very simple code completions where detailed context isn\u2019t needed. For code completion tasks: \u2013 It might auto-complete very basic snippets (e.g., quickly filling in a \"Hello World\" function or a simple loop structure) but can struggle with multi-line or context-intensive suggestions. Example: \u2013 Suppose you\u2019re building a short script and start typing a simple \"for\" loop. The o3-mini model might suggest the closing bracket or a simple \"end for\" statement, but wouldn\u2019t be expected to craft error handling or multi-part logic. - o1-mini (Level 1) Description: \u2013 Also in the \"mini\" family, this model is similarly lightweight but might be tuned slightly differently (or comes from an earlier iteration). \u2013 It is designed as a fast responder with minimal memory for context. For code completion tasks: \u2013 It can help with very basic syntax suggestions or filling in function signatures, though it may not capture deeper context (for instance, local variable types or dependencies across multiple lines). Example: \u2013 When writing a function definition in Python, o1-mini may complete the \"def function_name(\u2026\" part, but it might not automatically suggest detailed parameter checks or comments explaining the function behavior. - gpt-4o-mini (Level 2) Description: \u2013 This is a compact version of a GPT-4\u2013style model designed specifically for code completion. \u2013 It strikes a balance between speed and the ability to understand moderate context. For code completion tasks: \u2013 It can handle more context than the \"mini\" models, helping with writing short functions or code blocks that involve a mixture of syntax and logic. \u2013 It is better at maintaining consistent code structure over several lines. Example: \u2013 Imagine you\u2019re writing a Python function that processes a list. gpt-4o-mini might suggest not only the function\u2019s header but also hints for loop constructs, list comprehensions, or error checks within that function. - gpt-4o (Level 3) Description: \u2013 A full-fledged GPT-4\u2013style model tuned toward code completion, with a larger context window. \u2013 This means better understanding of the code context, dependencies, and even multi-file architectures. For code completion tasks: \u2013 It excels in generating syntactically correct and logically coherent code that spans multiple lines. \u2013 It can also provide helpful in-line comments or suggest optimizations. \u2013 It\u2019s well suited when you need complex completions like refactoring code or generating boilerplate code for class structures. Example: \u2013 If you\u2019re drafting a multi-step function that involves data parsing and error management, gpt-4o might complete the function with attention to exception handling, proper indentation, and integration with previously written code. - chatgpt-4o-latest (Level 4) Description: \u2013 The most advanced iteration in this set, incorporating the conversational strengths of ChatGPT with the code-centric abilities of GPT-4. \u2013 This model is updated with the latest improvements and is especially adept at interactive tasks. For code completion tasks: \u2013 It is tuned not only for static completions but also for interactive debugging, code explanation, and context-sensitive recommendations. \u2013 It excels in an IDE or conversational assistant scenario, where you might ask follow-up questions about the code it has generated or request adjustments on the fly. Example: \u2013 Suppose you wrote a function to handle API requests and then ask, \"Can you optimize the error handling here?\" chatgpt-4o-latest might not only modify the code to improve robustness but also explain the changes it suggests. This level of interaction is most valuable during pair-programming sessions or when learning new programming paradigms. Summary for a Programmer For very simple, fast completions, the \"mini\" models (o3-mini, o1-mini) are suitable \u2013 they are quick but have limited reasoning about the broader code context. gpt-4o-mini offers a middle ground, providing better syntactic and logical completions for small-to-medium code blocks with moderate context awareness. gpt-4o is ideal for more complex tasks that require deeper understanding, better integration with surrounding code, and fewer errors in multi-step code generation. chatgpt-4o-latest is best when you need an interactive, context-aware assistant that not only completes code but can also discuss and troubleshoot or improve your code based on feedback. Each step up in this lineup generally implies a trade-off of slightly more computation and latency for a significant boost in code completion quality, context awareness, and interactivity\u2014all of which are key for effective programmer assistance.","title":"Models Overview"},{"location":"ai-models/OVERVIEW/#ai-models-overview","text":"","title":"AI Models Overview"},{"location":"ai-models/OVERVIEW/#models","text":"o3-mini o1-mini gpt-4o-mini gpt-4o chatgpt-4o-latest","title":"Models"},{"location":"ai-models/OVERVIEW/#overview","text":"Below is an overview of the AI models and how they compare for code completion tasks in a programming context. In this lineup, each model represents an evolution in capability and context sensitivity when generating and refining code. (The numerical level identifiers can be thought of as \"contextual levels\" with higher numbers offering more advanced completions.)","title":"Overview"},{"location":"ai-models/OVERVIEW/#-o3-mini-level-0","text":"","title":"- o3-mini (Level 0)"},{"location":"ai-models/OVERVIEW/#description","text":"\u2013 This is a very lightweight model optimized for speed. \u2013 It has a limited capacity in terms of both context window and complexity of reasoning. \u2013 It works best for very simple code completions where detailed context isn\u2019t needed.","title":"Description:"},{"location":"ai-models/OVERVIEW/#for-code-completion-tasks","text":"\u2013 It might auto-complete very basic snippets (e.g., quickly filling in a \"Hello World\" function or a simple loop structure) but can struggle with multi-line or context-intensive suggestions.","title":"For code completion tasks:"},{"location":"ai-models/OVERVIEW/#example","text":"\u2013 Suppose you\u2019re building a short script and start typing a simple \"for\" loop. The o3-mini model might suggest the closing bracket or a simple \"end for\" statement, but wouldn\u2019t be expected to craft error handling or multi-part logic.","title":"Example:"},{"location":"ai-models/OVERVIEW/#-o1-mini-level-1","text":"","title":"- o1-mini (Level 1)"},{"location":"ai-models/OVERVIEW/#description_1","text":"\u2013 Also in the \"mini\" family, this model is similarly lightweight but might be tuned slightly differently (or comes from an earlier iteration). \u2013 It is designed as a fast responder with minimal memory for context.","title":"Description:"},{"location":"ai-models/OVERVIEW/#for-code-completion-tasks_1","text":"\u2013 It can help with very basic syntax suggestions or filling in function signatures, though it may not capture deeper context (for instance, local variable types or dependencies across multiple lines).","title":"For code completion tasks:"},{"location":"ai-models/OVERVIEW/#example_1","text":"\u2013 When writing a function definition in Python, o1-mini may complete the \"def function_name(\u2026\" part, but it might not automatically suggest detailed parameter checks or comments explaining the function behavior.","title":"Example:"},{"location":"ai-models/OVERVIEW/#-gpt-4o-mini-level-2","text":"","title":"- gpt-4o-mini (Level 2)"},{"location":"ai-models/OVERVIEW/#description_2","text":"\u2013 This is a compact version of a GPT-4\u2013style model designed specifically for code completion. \u2013 It strikes a balance between speed and the ability to understand moderate context.","title":"Description:"},{"location":"ai-models/OVERVIEW/#for-code-completion-tasks_2","text":"\u2013 It can handle more context than the \"mini\" models, helping with writing short functions or code blocks that involve a mixture of syntax and logic. \u2013 It is better at maintaining consistent code structure over several lines.","title":"For code completion tasks:"},{"location":"ai-models/OVERVIEW/#example_2","text":"\u2013 Imagine you\u2019re writing a Python function that processes a list. gpt-4o-mini might suggest not only the function\u2019s header but also hints for loop constructs, list comprehensions, or error checks within that function.","title":"Example:"},{"location":"ai-models/OVERVIEW/#-gpt-4o-level-3","text":"","title":"- gpt-4o (Level 3)"},{"location":"ai-models/OVERVIEW/#description_3","text":"\u2013 A full-fledged GPT-4\u2013style model tuned toward code completion, with a larger context window. \u2013 This means better understanding of the code context, dependencies, and even multi-file architectures.","title":"Description:"},{"location":"ai-models/OVERVIEW/#for-code-completion-tasks_3","text":"\u2013 It excels in generating syntactically correct and logically coherent code that spans multiple lines. \u2013 It can also provide helpful in-line comments or suggest optimizations. \u2013 It\u2019s well suited when you need complex completions like refactoring code or generating boilerplate code for class structures.","title":"For code completion tasks:"},{"location":"ai-models/OVERVIEW/#example_3","text":"\u2013 If you\u2019re drafting a multi-step function that involves data parsing and error management, gpt-4o might complete the function with attention to exception handling, proper indentation, and integration with previously written code.","title":"Example:"},{"location":"ai-models/OVERVIEW/#-chatgpt-4o-latest-level-4","text":"","title":"- chatgpt-4o-latest (Level 4)"},{"location":"ai-models/OVERVIEW/#description_4","text":"\u2013 The most advanced iteration in this set, incorporating the conversational strengths of ChatGPT with the code-centric abilities of GPT-4. \u2013 This model is updated with the latest improvements and is especially adept at interactive tasks.","title":"Description:"},{"location":"ai-models/OVERVIEW/#for-code-completion-tasks_4","text":"\u2013 It is tuned not only for static completions but also for interactive debugging, code explanation, and context-sensitive recommendations. \u2013 It excels in an IDE or conversational assistant scenario, where you might ask follow-up questions about the code it has generated or request adjustments on the fly.","title":"For code completion tasks:"},{"location":"ai-models/OVERVIEW/#example_4","text":"\u2013 Suppose you wrote a function to handle API requests and then ask, \"Can you optimize the error handling here?\" chatgpt-4o-latest might not only modify the code to improve robustness but also explain the changes it suggests. This level of interaction is most valuable during pair-programming sessions or when learning new programming paradigms.","title":"Example:"},{"location":"ai-models/OVERVIEW/#summary-for-a-programmer","text":"For very simple, fast completions, the \"mini\" models (o3-mini, o1-mini) are suitable \u2013 they are quick but have limited reasoning about the broader code context. gpt-4o-mini offers a middle ground, providing better syntactic and logical completions for small-to-medium code blocks with moderate context awareness. gpt-4o is ideal for more complex tasks that require deeper understanding, better integration with surrounding code, and fewer errors in multi-step code generation. chatgpt-4o-latest is best when you need an interactive, context-aware assistant that not only completes code but can also discuss and troubleshoot or improve your code based on feedback. Each step up in this lineup generally implies a trade-off of slightly more computation and latency for a significant boost in code completion quality, context awareness, and interactivity\u2014all of which are key for effective programmer assistance.","title":"Summary for a Programmer"},{"location":"ai-models/REFACTORING/","text":"Refactoring Code Models o3-mini o1-mini gpt-4o-mini gpt-4o chatgpt-4o-latest Breakdown Refactoring breakdown example of ask.ts Below is one way to describe what refactoring might look like for each \"model\" (here understood as a refactoring\u2010strategy level) along with the corresponding \"cost\" in OpenAI tokens. In our example, the dictionary { \"o3-mini\": 0, \"o1-mini\": 1, \"gpt-4o-mini\": 2, \"gpt-4o\": 3, \"chatgpt-4o-latest\": 4 } indicates that the simplest \"refactoring model\" (o3-mini) would propose almost no changes (0 tokens) while the most \"expensive\" one (chatgpt-4o-latest) would outline a comprehensive refactor (costing 4 tokens). Below are sample refactoring approaches for each \"model\": 1. o3-mini (Token Cost: 0) Minimal changes only\u2014essentially \"no\u2010refactor.\" \u2013 Leave the code structure mostly intact. \u2013 Perhaps perform very light cleanup (for example, consolidating redundant import statements or fixing minor spacing/formatting issues). Outcome: Code remains almost as originally written with nearly zero additional processing cost. 2. o1-mini (Token Cost: 1) Light refactoring with one or two minor improvements. \u2013 Extract the small utility (for example, the extractErrorMessage method) so that error handling is slightly centralized. \u2013 Simplify minor code repetitiveness (such as unifying similar error messages). Outcome: A few methods moved to a helper file with a small cost (1 token). 3. gpt-4o-mini (Token Cost: 2) Moderate refactoring with a couple of clear improvements. \u2013 Separate concerns by moving API interaction logic (submitQuestion and pollForResponse) into its own service module. \u2013 Clean up the command\u2019s control flow (for example, isolate file reading and prompt gathering into separate helper functions). Outcome: The source code is split into distinct modules (for config, API calls, and CLI handling) and is easier to maintain. Token cost: Around 2 tokens for the improvements. 4. gpt-4o (Token Cost: 3) More extensive refactoring with several structural changes. \u2013 Modularize the code: create separate modules for configuration (loadConfig), API handling (HTTP calls via axios), and the CLI interface (ask command). \u2013 Improve error handling (for example, centralize error logging or add custom error classes). \u2013 Introduce better type definitions and possibly separate business logic from user interaction. Outcome: The code is reorganized into cohesive units that are more testable and maintainable, at a cost estimated around 3 tokens. 5. chatgpt-4o-latest (Token Cost: 4) Full-blown comprehensive refactor that touches almost every aspect of the module. \u2013 Refactor the command into a thin controller layer while offloading API interactions, file input handling, and error management into separate, well-documented service modules. \u2013 Adopt a consistent coding style (e.g. uniform quotation marks, standardized async/await error handling) across the entire file. \u2013 Introduce a robust logging mechanism and possibly integrate automated testing for the refactored modules. \u2013 Optionally rework the polling logic to use more sophisticated patterns (such as an event-driven design or reactive streams) if needed. Outcome: A thoroughly modernized codebase that supports maintainability, scalability, and easier debugging, with the improvements \"costing\" about 4 tokens in estimated OpenAI usage. Summary Each \"model\" in our list represents a different \"level\" of refactoring intensity, with the number indicating the estimated token count (or \"cost\") to generate that full refactor plan via an API call. Lower token costs (0\u20131) mean very little change, while higher costs (3\u20134) mean a comprehensive, multi-step transformation. The above breakdown serves as one interpretation of how you might refactor the provided ask.ts file in progressively larger \"chunks\" of change.","title":"Code Refactoring"},{"location":"ai-models/REFACTORING/#refactoring-code","text":"","title":"Refactoring Code"},{"location":"ai-models/REFACTORING/#models","text":"o3-mini o1-mini gpt-4o-mini gpt-4o chatgpt-4o-latest","title":"Models"},{"location":"ai-models/REFACTORING/#breakdown","text":"Refactoring breakdown example of ask.ts Below is one way to describe what refactoring might look like for each \"model\" (here understood as a refactoring\u2010strategy level) along with the corresponding \"cost\" in OpenAI tokens. In our example, the dictionary { \"o3-mini\": 0, \"o1-mini\": 1, \"gpt-4o-mini\": 2, \"gpt-4o\": 3, \"chatgpt-4o-latest\": 4 } indicates that the simplest \"refactoring model\" (o3-mini) would propose almost no changes (0 tokens) while the most \"expensive\" one (chatgpt-4o-latest) would outline a comprehensive refactor (costing 4 tokens). Below are sample refactoring approaches for each \"model\":","title":"Breakdown"},{"location":"ai-models/REFACTORING/#1-o3-mini-token-cost-0","text":"Minimal changes only\u2014essentially \"no\u2010refactor.\" \u2013 Leave the code structure mostly intact. \u2013 Perhaps perform very light cleanup (for example, consolidating redundant import statements or fixing minor spacing/formatting issues). Outcome: Code remains almost as originally written with nearly zero additional processing cost.","title":"1. o3-mini (Token Cost: 0)"},{"location":"ai-models/REFACTORING/#2-o1-mini-token-cost-1","text":"Light refactoring with one or two minor improvements. \u2013 Extract the small utility (for example, the extractErrorMessage method) so that error handling is slightly centralized. \u2013 Simplify minor code repetitiveness (such as unifying similar error messages). Outcome: A few methods moved to a helper file with a small cost (1 token).","title":"2. o1-mini (Token Cost: 1)"},{"location":"ai-models/REFACTORING/#3-gpt-4o-mini-token-cost-2","text":"Moderate refactoring with a couple of clear improvements. \u2013 Separate concerns by moving API interaction logic (submitQuestion and pollForResponse) into its own service module. \u2013 Clean up the command\u2019s control flow (for example, isolate file reading and prompt gathering into separate helper functions). Outcome: The source code is split into distinct modules (for config, API calls, and CLI handling) and is easier to maintain. Token cost: Around 2 tokens for the improvements.","title":"3. gpt-4o-mini (Token Cost: 2)"},{"location":"ai-models/REFACTORING/#4-gpt-4o-token-cost-3","text":"More extensive refactoring with several structural changes. \u2013 Modularize the code: create separate modules for configuration (loadConfig), API handling (HTTP calls via axios), and the CLI interface (ask command). \u2013 Improve error handling (for example, centralize error logging or add custom error classes). \u2013 Introduce better type definitions and possibly separate business logic from user interaction. Outcome: The code is reorganized into cohesive units that are more testable and maintainable, at a cost estimated around 3 tokens.","title":"4. gpt-4o (Token Cost: 3)"},{"location":"ai-models/REFACTORING/#5-chatgpt-4o-latest-token-cost-4","text":"Full-blown comprehensive refactor that touches almost every aspect of the module. \u2013 Refactor the command into a thin controller layer while offloading API interactions, file input handling, and error management into separate, well-documented service modules. \u2013 Adopt a consistent coding style (e.g. uniform quotation marks, standardized async/await error handling) across the entire file. \u2013 Introduce a robust logging mechanism and possibly integrate automated testing for the refactored modules. \u2013 Optionally rework the polling logic to use more sophisticated patterns (such as an event-driven design or reactive streams) if needed. Outcome: A thoroughly modernized codebase that supports maintainability, scalability, and easier debugging, with the improvements \"costing\" about 4 tokens in estimated OpenAI usage.","title":"5. chatgpt-4o-latest (Token Cost: 4)"},{"location":"ai-models/REFACTORING/#summary","text":"Each \"model\" in our list represents a different \"level\" of refactoring intensity, with the number indicating the estimated token count (or \"cost\") to generate that full refactor plan via an API call. Lower token costs (0\u20131) mean very little change, while higher costs (3\u20134) mean a comprehensive, multi-step transformation. The above breakdown serves as one interpretation of how you might refactor the provided ask.ts file in progressively larger \"chunks\" of change.","title":"Summary"},{"location":"ai-models/code-files/ask.ts/","text":"Source Code Example code from \"@claire-ac/cli\" - ask.ts on Github Source code file for construction AI prompts for the CLaiRE API import { Command, Flags } from \"@oclif/core\"; import axios, { AxiosError } from \"axios\"; import inquirer from \"inquirer\"; import cliSpinners from \"cli-spinners\"; // Animated status indicator import ora from \"ora\"; // Loading spinner import { loadConfig } from \"../utils/config.js\"; import { formatCodeBlocks } from \"../utils/codeFormatter.js\"; export default class Ask extends Command { static description = \"Send a prompt to CLaiRE API and retrieve a response.\"; static flags = { prompt: Flags.string({ char: \"p\", description: \"Prompt to send\" }), inputFile: Flags.string({ char: \"F\", description: \"Path to file(s) containing the question input\", multiple: true }), contextIds: Flags.string({ char: \"c\", description: \"Comma-separated list of context IDs\", multiple: true }), }; static examples = [ '<%= config.bin %> <%= command.id %> -p \"How do I add ActiveAdmin to a Rails 7 app?\"', '<%= config.bin %> <%= command.id %> -p \"Refactor this file\" -F path/to/src/file.ts', '<%= config.bin %> <%= command.id %> -F path/to/input.txt', '<%= config.bin %> <%= command.id %> -p \"Help me combine these files:\" -F path/to/file1.ts -F path/to/file2.ts', '<%= config.bin %> <%= command.id %> -p \"Analyze this code\" -c 123 -c 456', ]; async run() { const { flags } = await this.parse(Ask); const { token: authToken, host: apiHost } = loadConfig().api; const { id: projectId } = loadConfig().project; if (!authToken) { this.error(\"Missing CLaiRE API token. Set it using `claire config -k YOUR_AUTH_TOKEN`.\"); } if (!projectId) { this.error(\"CLaiRE Project Not Set. Set it using `claire api:project:set`.\"); } let content = await this.getInitialQuestion(flags); let contextIds: number[] = this.parseContextIds(flags.contextIds); while (true) { try { const questionId = await this.submitQuestion(apiHost, authToken, projectId, content, contextIds); if (!questionId) return; contextIds.push(questionId); // Append new question ID to context const response = await this.pollForResponse(apiHost, authToken, questionId); this.log(\"\\n\ud83d\udca1 CLaiRE API Response:\"); this.log(formatCodeBlocks(response)); const { isFollowUp } = await inquirer.prompt([ { type: \"confirm\", name: \"isFollowUp\", message: \"Would you like to ask a follow-up question?\", default: false }, ]); if (!isFollowUp) break; const { followUpQuestion } = await inquirer.prompt([ { type: \"input\", name: \"followUpQuestion\", message: \"Enter your follow-up question:\" }, ]); content = followUpQuestion.trim(); } catch (error) { this.error(`${error instanceof Error ? error.message : \"Unknown error\"}`); } } } private async submitQuestion(apiHost: string, authToken: string, projectId: number, content: string, contextIds: number[]): Promise<number | null> { try { const response = await axios.post( `${apiHost}/api/questions`, { question: { project_id: projectId, content, context_ids: contextIds } }, { headers: { Authorization: `Bearer ${authToken}`, \"Content-Type\": \"application/json\" } } ); return response.data?.id || null; } catch (error) { const errorMessage = this.extractErrorMessage(error); this.error(`\u274c ${errorMessage}`); return null; } } private async pollForResponse(apiHost: string, authToken: string, questionId: number): Promise<string> { const spinner = ora({ text: \"\ud83d\udd04 Waiting for response from CLaiRE API...\", spinner: cliSpinners.dots }).start(); const maxRetries = 50; let attempt = 0; while (attempt < maxRetries) { try { await new Promise((resolve) => setTimeout(resolve, 3000)); const response = await axios.get(`${apiHost}/api/responses/${questionId}`, { headers: { Authorization: `Bearer ${authToken}` }, }); if (response.data?.content) { spinner.succeed(\"\u2705 Response received!\"); return response.data.content; } } catch (error: any) { const errorMessage = this.extractErrorMessage(error); if (error.response?.data?.errors?.includes(\"Response doesn't exist\")) { spinner.text = `\u23f3 Still waiting for CLaiRE API response... [Attempt: ${attempt + 1}/10]`; } else { spinner.fail(`\u274c Error fetching response: ${errorMessage}`); throw new Error(errorMessage); } } attempt++; } spinner.fail(\"\u274c Timed out waiting for CLaiRE API response.\"); throw new Error(\"No response received from CLaiRE API after multiple attempts.\"); } private extractErrorMessage(error: unknown): string { if (axios.isAxiosError(error)) { return error.response?.data?.messages || error.response?.data?.error || error.message || \"Unknown API error\"; } return error instanceof Error ? error.message : \"An unknown error occurred\"; } private async getInitialQuestion(flags: any): Promise<string> { let prompt = flags.prompt ? flags.prompt.trim() : \"\"; let fileContents = []; if (flags.inputFile && flags.inputFile.length > 0) { const fs = await import(\"fs/promises\"); for (const filePath of flags.inputFile) { try { const content = (await fs.readFile(filePath, \"utf-8\")).trim(); fileContents.push(`\ud83d\udcc4 **File: ${filePath}**\\n${content}`); } catch (error) { this.error(`\u274c Failed to read input file: ${filePath}`); } } } let combinedQuestion = prompt; if (fileContents.length > 0) { combinedQuestion += `\\n\\n---\\n${fileContents.join(\"\\n\\n---\\n\")}`; } if (combinedQuestion.trim()) return combinedQuestion; const { userPrompt } = await inquirer.prompt([ { type: \"input\", name: \"userPrompt\", message: \"Please enter a prompt:\" }, ]); return userPrompt.trim(); } private parseContextIds(contextIds: string[] | undefined): number[] { if (!contextIds || contextIds.length === 0) return []; try { return contextIds.flatMap(id => id.split(\",\")).map(id => parseInt(id.trim(), 10)).filter(id => !isNaN(id)); } catch { this.error(\"\u274c Invalid context IDs provided. Please ensure they are numbers.\"); return []; } } }","title":"ask.ts Source File"},{"location":"ai-models/code-files/ask.ts/#source-code","text":"","title":"Source Code"},{"location":"ai-models/code-files/ask.ts/#example-code-from-claire-accli","text":"","title":"Example code from \"@claire-ac/cli\""},{"location":"ai-models/code-files/ask.ts/#-askts-on-github","text":"Source code file for construction AI prompts for the CLaiRE API import { Command, Flags } from \"@oclif/core\"; import axios, { AxiosError } from \"axios\"; import inquirer from \"inquirer\"; import cliSpinners from \"cli-spinners\"; // Animated status indicator import ora from \"ora\"; // Loading spinner import { loadConfig } from \"../utils/config.js\"; import { formatCodeBlocks } from \"../utils/codeFormatter.js\"; export default class Ask extends Command { static description = \"Send a prompt to CLaiRE API and retrieve a response.\"; static flags = { prompt: Flags.string({ char: \"p\", description: \"Prompt to send\" }), inputFile: Flags.string({ char: \"F\", description: \"Path to file(s) containing the question input\", multiple: true }), contextIds: Flags.string({ char: \"c\", description: \"Comma-separated list of context IDs\", multiple: true }), }; static examples = [ '<%= config.bin %> <%= command.id %> -p \"How do I add ActiveAdmin to a Rails 7 app?\"', '<%= config.bin %> <%= command.id %> -p \"Refactor this file\" -F path/to/src/file.ts', '<%= config.bin %> <%= command.id %> -F path/to/input.txt', '<%= config.bin %> <%= command.id %> -p \"Help me combine these files:\" -F path/to/file1.ts -F path/to/file2.ts', '<%= config.bin %> <%= command.id %> -p \"Analyze this code\" -c 123 -c 456', ]; async run() { const { flags } = await this.parse(Ask); const { token: authToken, host: apiHost } = loadConfig().api; const { id: projectId } = loadConfig().project; if (!authToken) { this.error(\"Missing CLaiRE API token. Set it using `claire config -k YOUR_AUTH_TOKEN`.\"); } if (!projectId) { this.error(\"CLaiRE Project Not Set. Set it using `claire api:project:set`.\"); } let content = await this.getInitialQuestion(flags); let contextIds: number[] = this.parseContextIds(flags.contextIds); while (true) { try { const questionId = await this.submitQuestion(apiHost, authToken, projectId, content, contextIds); if (!questionId) return; contextIds.push(questionId); // Append new question ID to context const response = await this.pollForResponse(apiHost, authToken, questionId); this.log(\"\\n\ud83d\udca1 CLaiRE API Response:\"); this.log(formatCodeBlocks(response)); const { isFollowUp } = await inquirer.prompt([ { type: \"confirm\", name: \"isFollowUp\", message: \"Would you like to ask a follow-up question?\", default: false }, ]); if (!isFollowUp) break; const { followUpQuestion } = await inquirer.prompt([ { type: \"input\", name: \"followUpQuestion\", message: \"Enter your follow-up question:\" }, ]); content = followUpQuestion.trim(); } catch (error) { this.error(`${error instanceof Error ? error.message : \"Unknown error\"}`); } } } private async submitQuestion(apiHost: string, authToken: string, projectId: number, content: string, contextIds: number[]): Promise<number | null> { try { const response = await axios.post( `${apiHost}/api/questions`, { question: { project_id: projectId, content, context_ids: contextIds } }, { headers: { Authorization: `Bearer ${authToken}`, \"Content-Type\": \"application/json\" } } ); return response.data?.id || null; } catch (error) { const errorMessage = this.extractErrorMessage(error); this.error(`\u274c ${errorMessage}`); return null; } } private async pollForResponse(apiHost: string, authToken: string, questionId: number): Promise<string> { const spinner = ora({ text: \"\ud83d\udd04 Waiting for response from CLaiRE API...\", spinner: cliSpinners.dots }).start(); const maxRetries = 50; let attempt = 0; while (attempt < maxRetries) { try { await new Promise((resolve) => setTimeout(resolve, 3000)); const response = await axios.get(`${apiHost}/api/responses/${questionId}`, { headers: { Authorization: `Bearer ${authToken}` }, }); if (response.data?.content) { spinner.succeed(\"\u2705 Response received!\"); return response.data.content; } } catch (error: any) { const errorMessage = this.extractErrorMessage(error); if (error.response?.data?.errors?.includes(\"Response doesn't exist\")) { spinner.text = `\u23f3 Still waiting for CLaiRE API response... [Attempt: ${attempt + 1}/10]`; } else { spinner.fail(`\u274c Error fetching response: ${errorMessage}`); throw new Error(errorMessage); } } attempt++; } spinner.fail(\"\u274c Timed out waiting for CLaiRE API response.\"); throw new Error(\"No response received from CLaiRE API after multiple attempts.\"); } private extractErrorMessage(error: unknown): string { if (axios.isAxiosError(error)) { return error.response?.data?.messages || error.response?.data?.error || error.message || \"Unknown API error\"; } return error instanceof Error ? error.message : \"An unknown error occurred\"; } private async getInitialQuestion(flags: any): Promise<string> { let prompt = flags.prompt ? flags.prompt.trim() : \"\"; let fileContents = []; if (flags.inputFile && flags.inputFile.length > 0) { const fs = await import(\"fs/promises\"); for (const filePath of flags.inputFile) { try { const content = (await fs.readFile(filePath, \"utf-8\")).trim(); fileContents.push(`\ud83d\udcc4 **File: ${filePath}**\\n${content}`); } catch (error) { this.error(`\u274c Failed to read input file: ${filePath}`); } } } let combinedQuestion = prompt; if (fileContents.length > 0) { combinedQuestion += `\\n\\n---\\n${fileContents.join(\"\\n\\n---\\n\")}`; } if (combinedQuestion.trim()) return combinedQuestion; const { userPrompt } = await inquirer.prompt([ { type: \"input\", name: \"userPrompt\", message: \"Please enter a prompt:\" }, ]); return userPrompt.trim(); } private parseContextIds(contextIds: string[] | undefined): number[] { if (!contextIds || contextIds.length === 0) return []; try { return contextIds.flatMap(id => id.split(\",\")).map(id => parseInt(id.trim(), 10)).filter(id => !isNaN(id)); } catch { this.error(\"\u274c Invalid context IDs provided. Please ensure they are numbers.\"); return []; } } }","title":"- ask.ts on Github"}]}